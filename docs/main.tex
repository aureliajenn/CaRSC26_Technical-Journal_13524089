\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{datetime2}
\usepackage{float}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}

\lstset{
    backgroundcolor=\color{codegray},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{teal},
}

\title{Technical Journal}
\author{Aurelia Jennifer Gunawan\\13524089}
\date{Last Updated: 2026-02-07}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Catatan Pendidikan}
\subsection{Arsitektur Sistem UAV}
\subsubsection{Komponen" UAV}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{diagram_komponen.png}
    \label{fig:placeholder}
\end{figure}
Wahana terdiri atas airframe dan sistem propulsi. Airframe pada pesawat terdiri atas fuselage, sayap, dan ekor. Airframe pada drone terdiri atas frame atau center plate, dan arm. Sistem propulsi terdiri atas tiga komponen: 
\begin{itemize}
    \item Propeller\\Menghasilkan gaya angkat/dorong melalui rotasi.
    \item Motor\\Mengubah energi listrik menjadi energi kinetik rotasi untuk memutar \textit{propeller}
    \item Electronic Speed Controller (ESC)\\Mengatur kecepatan dan arah putaran motor sesuai perintah dari FC
    \item Baterai Lithium Polymer (LiPo)\\Sumber energi utama
\end{itemize}
\textit{Flight controller} berperan sebagai sistem saraf motorik dari UAV yang memproses dan menyatukan data dari sensor serta menjalankan algoritma kontrl untuk mengendalikan penerbangan, baik berdasarkan perintah pilot (dari GCS0 maupun secara otonom (dari companion computer). FC terdiri atas beberapa \textit{chip} atau unit:
\begin{itemize}
    \item Microcontroller Unit (MCU)
    Prosesor utama yang menjalankan \textit{firmware} dan mengolah semua data dan logika kontrol penerbangan
    \item Barometer\\Mengukur tekanan atmosfer untuk mengestimasi ketinggian wahana
    \item Inertial Measurement Unit (IMU)
    Mengintegrasikan \textit{accelerometer} dan \textit{gyroscope} yang mengukur percepatan, kecepatan sudut, dan orientasi UAV untuk mengetahui pergerakannya.
    \item Blackbox
    Mencatat log keseluruhan UAV sejak arm hingga disarm, untuk analisis pasca penerbangan.
    \item Modul GNSS
    Menerima sinyal dari sistem navihasi satelit global, seperti GPS, GLONASS, Galileo, dan BeiDou untuk menentukan posisi, kecepatan, dan waktu UAV.
    \item Airspeed sensor
    Mengukur kecepatan relatif wahana terhadap udara menggunakan tabung pitot
    \item Magnetometer (kompasnya UAV)
    Mendeteksi medan magnet bumi untuk menentukan arah mata angin yang dituju wahana. Biasanya terintegrasi dalam modul GNSS sebagai \textit{chip} kompas.
\end{itemize}
Payload dapat berupa: 
\begin{itemize}
    \item Kamera FPV
    Menyediakan video real time ke pilot/GCS
    \item Kamera Depth
    Menghasilkan peta kedalaman/\textit{depth map} dan titik 3D secara real-time
    \item Kamera Tracking
    Mengestimasi posisi dan orientasi UAV secara real time tanpa GPS
    \item LiDAR
    Sensor pemetaan 3D high precision untuk misi survei topografi dan kehutanan
    \item Sensor Partikel
    Sensor untuk memantau kualitas udara
    \item and more...
\end{itemize}
Ground control station (GCS) adalah sistem di darat untuk memantau, mengendalikan, dan mengelola misi uAV lewat gelombang radio. GCS terdiri atas remote controller, laptop dan aplikasi GCS, modul radio telemetry, dan antena yagi. UAV dan GCS melakukan komunikasi dengan \textbf{gelombang radio} pada spektrum frekuensi tertentu. Jalur komunikasi fungsional yang terbentuk dari pertukaran data lewat frekuensi ini disebut dengan \textbf{link}. Terdapat dua jenis link utama dalam sistem UAV:
\begin{enumerate}
    \item C2/Data/Radio/Non-payload Link
    Saluran utama yang bertanggung jawab atas pengendalian UAV. Secara fisik hubungan ini dijalin antara \textit{radio transceiver} di GCS dan di UAV.
    Terdiri atas: 
    \begin{itemize}
        \item Uplink (\textit{telecommand}) mengirimkan perintah kendali dari GCS/pilot ke UAV
        \item Downlink (\textit{telemetry}) mengirimkan data status UAV (attitude, baterai, GPS, ketinggian, dsb.) ke GCS
    \end{itemize}
    \item Payload Link
    Saluarn khusus untuk mengirimkan data dari payload ke GCS secara real-time. Untuk kamera, link ini dijalin secara fisik antara VTX (video transmitter) dan VRX (video receiver)
\end{enumerate}
Companion computer adalah "otak" yang melakukan komputasi tingkat tinggi, yang melengkapi FC. CC disambungkan ke FC secara serial dan berkomunikasi dengan protokol MAVLINK. Payload dan sensor memberikan data ke CC untuk mengambil keputuasn, lalu CC mengirimkan perintah ke FC untuk dieksekusi. 

\subsubsection{Komunikasi}
Terdapat dua cara mengirim data:
\begin{enumerate}
    \item Wired
    \begin{itemize}
        \item Digunakan untuk komunikasi jarak pendek antarkomponen
        \item Media fisik berupa kabel tembaga
        \item Laju transfer sangat tinggi, latensi rendah, dan lebih baik dari segi keamanan, tapi jangkauannya terbatas
    \end{itemize}
    \item Wireless
    \begin{itemize}
        \item Digunakan untuk komunikasi jarak jauh, misalnya antara GCS dan UAV
        \item Media fisik berupa gelombang radio dari transceiver
        \item Mobilitas lebih tinggi, tapi rentan interferensi dan bandwidth, serta latensi terbatas
    \end{itemize}
\end{enumerate}
Proses pengiriman data diatur oleh \textbf{protokol}. Protokol mengatur: 
\begin{enumerate}
    \item sintaks: cara menyusun struktur data
    \item semantik: makna dari setiap bit data
    \item sinkronisasi: keselarasan kecepatan pengiriman data
\end{enumerate}
Wired: \begin{enumerate}
    \item UART (Universal Asynchronous Receiver-Transmitter)
    \begin{itemize}
        \item Bersifat \textbf{asinkron}. Pengirim dan penerima menyepakati laju pengiriman data (baud rate, bit/s), panjang data, dan bit (0 atau 1) untuk menandakan awal dan akhir satu pesan. 
        \item Mempunyai dua pin, yaitu \textbf{RX} dan \textbf{TX}. RX untuk menerima data dari perangkat lain. TX untuk mengirim data ke perangkat lain. 
        \item Digunakan untuk menghubungkan FC ke modul telemtri, GPS, dan CC.
    \end{itemize}
    \item SPI (Serial Peripheral Interface)
    \begin{itemize}
        \item Bersifat \textbf{sinkron}. 
        \item Mempunyai empat pin, yaitu \textbf{SCLK, MOSI, MISO}, dan \textbf{SS}. SCLK mirip SCL di I2C. MOSI adalah jalur data dari master ke slave. MISO jalur data dari slave ke master. SS adalah pin untuk memilih slave mana yang diajak bicara. 
        \item Digunakan untuk menghubungkan FC (master) dengan komponen kritikal (slave) dengan data padat seperti IMU dan blackbox
    \end{itemize}
    \item I2C (Inter-Integrated Circuit)
    \begin{itemize}
        \item Bersifat \textbf{sinkron}. 
        \item Mempunyai dua pin, yaitu SDA dan SCL. SDA adalah jalur dua arah untuk mengirim dan menerima data. SCL membawa sinyal detak dari master untuk sinkronisasi. 
        \item Digunakan untuk menghubungkan FC ke sensor berkecepatan rendah seperti airspeed sensor dan barometer
    \end{itemize}
\end{enumerate}
Wireless: 
\begin{enumerate}
    \item TCP (Transmission Control Protocol)
    \begin{itemize}
        \item Sebelum mengirim data, pengirim dan penerima melakukan \textit{\textbf{handshake}} untuk memastikan kesiapan pengiriman data. 
        \item Kalau ada data yang hilang/rusak di tengah jalan, pengirim berhenti dan mengirim ulang data tsb sampai diterima secara sempurna. 
        \item Digunakan untuk \textbf{upload waypoints} atau \textbf{mengubah parameter}, karena merupakan informasi krusial yang tidak boleh salah satu bit pun (dapat berakibat fatal), dan reliability diprioritaskan.
    \end{itemize}
    \item UDP (User Datagram Protocol)
    \begin{itemize}
        \item Data dikirim terus menerus tanpa memedulikan apakah penerima sudah siap atau data sampai secara sempurna.
        \item Pengiriman data sangat cepat dengan latensi rendah, tapi tidak reliable
        \item Digunakan untuk \textbf{streaming video dan data telemtry secara real time}
    \end{itemize}
\end{enumerate}

Setiap data yang dikirim umumnya dikemas berdasarkan protokol perangkat lunak untuk UAV, seperti MAVLink (Micro Air Vehicle Link). MAVLink adalah protokol komunikasi pesan \textit{open source} yang sangat ringan dan penting karena jaringan nirkabel memiliki \textit{bandwidth} yang terbatas.
\begin{itemize}
    \item Setiap wahana UAV memiliki system ID (1-255) dan setiap komponen dalam wahana memiliki component ID. 
    \item UAV mengirimkan pesan HEARTBEAT secara rutin untuk memberi tahu GCS bahwa koneksi masih aktif dan sistem dalam keadaan normal. 
    \item MAVLink lebih sering menggunakan UDP (kalau pake TCP akan ada delay yang berpotensi membuat wahana \textit{crash}. MAVLink memiliki \textit{checksum}, kode verifikasi yang dihasilkan secara matematis dari isi pesan itu sendiri sehingga ketidakcocokan \textit{checksum} akan mengakibatkan paket data terbuang.)
\end{itemize}
\subsubsection{Logika Operasi}
System state dan flight mode menentukan seberapa besar kontrol pilot dibandingkan dengan kontrol otomatis oleh FC dan apa yang dilakukan wahana dalam suatu kondisi/mode. 
\begin{itemize}
    \item \textbf{System State}
    Sebelum terbang, wahana harus melewati tahapan status berikut: 
    \begin{enumerate}
        \item \textbf{Initialization}:  FC melakukan kalibrasi sensor internal tepat setelah baterai dihubungkan. 
        \item \textbf{Pre-arm Check}: Diagnosa otomatis yang dilakukan wahana untuk memastikan kondisinya layak terbang.
        \item \textbf{Disarm}: Kondisi standar saat di darat. Motor terkunci total dan tidak akan berputar. 
        \item \textbf{Arm}: Kondisi aktif, motor mulai berputar pada kecepatan rendah dan wahana siap menerima input \textit{throttle} untuk lepas landas. 
    \end{enumerate}
    \item \textbf{Flight Mode}
    Berikut adalah beberapa contoh mode terbang untuk ArduPilot:
    \begin{enumerate}
        \item \textbf{Acro}: Kendali penuh tanpa stabilisasi otomatis.
        \item \textbf{Stabilize}: Wahana otomatis kembali datar jika stick dilepas.
        \item \textbf{Alt-Hold}: Menjaga ketinggian otomatis, posisi horizontal tetap diatur manual.
        \item \textbf{Loiter}: Menjaga koordinat dan ketinggian secara statis di udara.
        \item \textbf{RTL/RTH (Return To Land/Home)}: Kembali ke titik landas/home.
        \item \textbf{Auto}: Menjalankan misi berdasarkan waypoints yang telah ditentukan.
        \item \textbf{Guided}: Bergerak secara interaktif berdasarkan input pada peta di GCS. 
    \end{enumerate}
\end{itemize}
\textbf{Mekanisme Failsafe} adalah prosedur otomatis yang dilakukan UAV ketika terjadi kegagalan sistem untuk mencegah \textit{crash} atau kehilangan wahana. Beberapa pemicu failsafe meliputi: 
\begin{itemize}
    \item \textbf{RC Link Lost}: sinyal antara \textit{remote control} dan \textit{receiver} di UAV terputus
    \item \textbf{GCS Link Lost}: koneksi telemetri antara GCS dan UAV terputus
    \item \textbf{Low Battery}
    \item \textbf{EKF Check/GPS Glitch}
    \item \textbf{Fence Breach}: wahana keluar dari batas wilayah geografis yang sudah ditentukan (geofence).
\end{itemize}
Beberapa tindakan yang diambil FC dalam kondisi failsafe (di-configure sebelumnya) adalah: 
\begin{itemize}
    \item RTL
    \item Land
    \item Brake
    \item and more...
\end{itemize}

\subsection{Dasar Pemrograman}
\subsubsection{Konsep Dasar OOP}
Why  OOP?
\begin{itemize}
    \item Fokus pada objek yang memodelkan benda nyata (data + perilaku)
    \item Modularitas tinggi, kode bisa dipecah menjadi bagian" (class)
    \item Rapi, terstruktur, dan mudah di-maintenance
Class = skematik/datasheet komponen (rancangan)
Object = Komponen fisik yang sudah dirakit
Sebuah class memiliki atribut (variabel yang menyimpan data), dan metode (fungsi/prosedur yang mendefinisikan tindakan atau perilaku yang bisa dilakukan oleh class tersebut). 
\textbf{Encapsulation} :
\begin{enumerate}
    \item Membungkus data sensitif agar tidak bisa diakses sembarangan dari luar. Akses untuk membaca dan mengubah data dilakukan dengan \textit{getter} dan \textit{setter}.
    \item Menentukan siapa yang bisa mengakses suatu atribut/method dari suatu kelas dengan access modifier:
    
    \begin{table}[h]
        \centering
        \begin{tabular}{cccc}
            \textbf{Modifier} & \textbf{Own Class} & \textbf{Derived Class} & \textbf{Main()}\\
            \textbf{Public} & Yes & Yes & Yes\\
            \textbf{Protected} & Yes & Yes & No\\
            \textbf{Private} & Yes & No & No\\
        \end{tabular}
    \end{table}
\end{enumerate}
\textbf{Abstraction} bertujuan untuk menyembunyikan proses/cara kerja di belakang layar.

\textbf{Inheritance} (based on prinsip Don't Repeat Yourself/DRY). Parent class/base class adalah class yang mewariskan sifat. Child class/derived class adalah class yang mewarisi sifat dari parent.

\textbf{Polymorphism} adalah prinsip yang memungkinkan respon yang berbeda-beda berdasarkan perintah yang sama, tergantung object. 
\end{itemize}

\subsubsection{Design Pattern}
Pola umum yang digunakan untuk mempermudah pengembangan aplikasi.\\
\textbf{Producer-Consumer Pattern} adalah pola desain konkuren, di aman satu atau lebih thread producer menghasilkan objek yang diantreankan, lalu dikonsumsi oleh satu atau lebih consumer. Objek yang diantreankan umumnya mewakili beberapa pekerjaan yang perlu dilakukan.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{producer-consumer.png}
\end{figure}

\subsubsection{Error Handling}
Mekanisme \textbf{Try-Catch}: 
\begin{itemize}
    \item Blok try berisi kode yang dicoba untuk dijalankan
    \item Kalau ada error pindah ke block catch dengan Exception yang sesuai
    \item better than if-else karena dapat lebih mengcover error tak terduga
\end{itemize}

\subsubsection{Virtual Function}
Virtual function adalah fungsi parent class/base class yang dideklarasikan dengan kata kunci virtual, dan di-override dala child class/derived class. Fungsi virtual memungkinkan \textit{runtime polymorphism}, dimana fungsi yang tepat dipanggil melalu base class pointer atau reference.

\subsubsection{Pengenalan Pemrograman Konkuren}
\textbf{Multithreading}
\begin{itemize}
    \item Thread adalah unit terkecil dari proses
    \item Multithreading adalah teknik memecah proses menjadi task kecil yang dijalankan oleh thread di dalamnya sehingga bisa berjalan secara konkuren/bersama. 
    \item Problems? Race condition, dan deadlock!
\end{itemize}
\textbf{Race condition}: 
\begin{itemize}
    \item thread saling mengakses resources yang sama, maka dapat terjadi rebutan resources antar thread.
    \item solusi: use \textbf{mutex/lock} sehingga hanya satu thread yang bisa mengakses suatu resource di suatu waktu.
\end{itemize} 
\textbf{Deadlock}: 
\begin{itemize}
    \item dua atau lebih proses/pihak dapat saling menunggu resources yang dipegang oleh pihak lain
    \item solusi: 
    \begin{enumerate}
        \item deadlock prevention: menghilangkan salah satu syarat kondisi terjadinya deadlock, yaitu mutual exclusion, hold and wait, no preemption, dan circular wait. 
        \item deadlock avoidance dengan banker's algorithm (memeriksa secara dinamis status alokasi resource untuk memastikan sistem tidak memasuki unsafe state)
        \item deadlock detection and recovery dengan timeout dan deteksi cycle. 
    \end{enumerate} 
\end{itemize}

\subsection{MAVLink}
\subsubsection{Pendahuluan}
MAVLink atau Micro Air Vehicle Link adalah protokol komunikasi pesan open source yang sangat ringan, yang penting karena jaringan nirkabel memiliki bandwidth terbatas. MAVLink mendukung komunikasi dua arah yang efisien dan memungkinkan integrasi wahana UAV denagn jaringan internet. 
\subsubsection{System ID, Component ID, Message ID}
Setiap entitas yang bisa mengirim atau menerima pesan MAVLink harus punya identitas unik. Suatu sistem MAVLink (wahana/GCS) bisa memiliki banyak komponen. 
\begin{enumerate}
    \item System ID
    \begin{itemize}
        \item Identitas unik satu sistem UAV.
        \item Rentang nilai 1-255.
        \item System ID 255 dialokasikan untuk GCS.
        \item Semua komponen dalam wahana yang sama memiliki system ID yang sama.
    \end{itemize}
    \item Component ID
    \begin{itemize}
        \item Identitas spesifik untuk setiap komponen atau subsistem dalam satu wahana.
        \item Sudah ada penomoran bawaannya dari MAVLink, i.e. FC: 1, Kamera: 100-105, Gimbal: 154, CC: 191-194.
    \end{itemize}
\end{enumerate}
MAVLink punya berbagai jenis pesan untuk pertukaran data antarkomponen dalam sistem UAV. Setiap pesan memiliki message ID yang unik. Untuk MAVLink v1 ada 255, untuk MAVLink v2 hingga 16 juta. Dialect adalah kumpulan pesan yang dapat disesuaikan dengan kebutuhan sistem tertentu. Berdasarkan tujuannya, message dibagi menjadi dua macam: 
\begin{enumerate}
    \item State messages: dikirim dari wahana ke GCS untuk melaporkan status (posisi, orientasi, baterai, dsb.)
    \item Command messages: dikirim dari GCS ke wahana untuk mengeksekusi aksi atau misi tertentu (event based)
\end{enumerate}

\subsubsection{Pola Interaksi dengan MAVLink}
\begin{enumerate}
    \item Streaming (Telemetri)
    \begin{itemize}
        \item Dipakai untuk \textbf{data yang harus dipantau terus-menerus} secara real-time, yaitu pesan bertipe \textbf{state messages}. Contohnya heartbeat, attitude, global\_position\_int
        \item Bersifat \textbf{broadcast} atau \textbf{satu arah} secara periodik dari wahana ke GCS
        \item Mengandalkan message ID untuk menentukan jenis data tanpa alamat tujuan spesifik
    \end{itemize}
    \item Microservices
    \begin{itemize}
        \item Dipakai untuk \textbf{perintah kritis yang butuh konfirmasi}, yaitu pesan bertipe \textbf{command messages}. Contohnya upload/download waypoint, instruksi arm/disarm/takeoff/land, dan membaca/mengubah pengaturan internal (parameter) pada FC.
        \item Bersifat \textbf{point-to-point} atau \textbf{dua arah}, seperti client-service
        \item Menggunakan system ID dan component ID agar perintah tidak salah sasaran.
    \end{itemize}
\end{enumerate}
\subsubsection{Anatomi Paket MAVLink}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{anatomimav.png}
\end{figure}
\begin{itemize}
    \item Setiap paket dimulai dengan STX (0XFD) sebagai penanda bahwa paket tersebut menggunakan protokol MAVLink
    \item SYS\_ID (System ID) dan COMP\_ID (Component ID) untuk identitas
    \item MSG\_ID (Message ID) untuk jenis message yang dikirim
    \item PAYLOAD untuk membungkus konten data utama
    \item Checksum memastikan paket tidak corrupt saat diterima, menggunakan algoritma CRC-16 (ITU X.25) untuk menghasilkan kode verifikasi 2-byte (CKA dan CKB) dengan data dari LEN hingga PAYLOAD
    \item SIGNATURE adalah tanda tangan digital (SHA-256) untuk memastikan bahwa paket MAVLink yang diterima berasal dari pihak terpercaya. 
\end{itemize}
\subsubsection{MAVLink Interfaces}
\begin{enumerate}
    \item MAVProxy: CLI-based GCS, yang sangat ringan dan stabil
    \item MAVSDK: Software development kit untuk membangun aplikasi berbasis MAVLink dengan bahasa tingkat tinggi (C++, Python, dsb.)
    \item MAVROS (MAVLink + ROS): Penerjemah antara MAVLink dan ROS pada drone berbasis ROS
\end{enumerate}
\subsection{Software In The Loop (SITL)}
\subsubsection{Pendahuluan}
Software in the loop (SITL) adalah metode untuk menjalankan dan menguji sistem autopilot wahana UAV tanpa menggunakan perangkat keras fisik. Dalam SITL, FC dan lingkungan (hukum fisika) disimulasikan oleh perangkat lunak. Selain itu, flight stack, seperti ardupilot/PX4, dijalankan seperti program biasa di komputer. Pengujian melalui SITL bertujuan untuk memeriksa ketepatan implementasi logika navigasi karena tidak ada risio kerusakan fisik akibat crash

\subsubsection{Arsitektur sistem SITL}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{arsitekturSITL.png}
\end{figure}
Arsitektur SITL memisahkan simulasi fisik dan logika kontrol drone. Gazebo untuk simulasi fisik, yang menghasilkan data sensor virtual (flight datam vehicle state, sensor data, dsb.). Data sensor virtual dikirim ke Ardupilot SITL melalui protokol UDP. Ardupilot mensimulasikan FC, yang memproses data sensor dengan algoritma navigasi, EKF, dan kontrol untuk menghitung perintah motor. Ardupilot akan mengirim kembali output motor ke Gazebo agar pergerakan drone di-update. Di sisi lain, Ardupilot berkomunikasi dengan MAVProxy melalui protokol TCP untuk menerima perintah kontrol, mengirim waypointm dan mengendalikan misi. Selain itu, MAVProxy juga mengirimkan data motor speeds dan output commands ke Ardupilot melalui protokol UDP. 

\subsubsection{Tools}
\begin{enumerate}
    \item Ardupilot: flight stack untuk mensimulasikan FC
    \item Gazebo harmonic: simulasi fisika dan lingkungan serta dinamika wahana yang realistis
    \item MAVProxy: jembatan komunikasi antara pengguna dan flight stack
\end{enumerate}

\subsection{Dasar-dasar Web Development}
\subsubsection{Istilah dalam Web Development}
\begin{itemize}
    \item IP: Internet protocol
    \item Port: Address untuk proses tertentu
    \item URL: Uniform Resource Locator, alamat
    \item HTTP: HyperText Transfer Protocol, protokol untuk web app
    \item API: Application Programming Interface
\end{itemize}
\subsubsection{Arsitektur}
Sebuah web app bekerja dengan menggunakan arsitektur client-server. Web client disini adalah browser yang berjalan di device pengguna. Sedanggkan web server adalah server yang memberi konten web apapun agar bisa diakses oleh user. Client dan server berkomunikasi melalui protokol HTTP(S).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{fe-be.png}
\end{figure}

\subsubsection{Frontend dan Backend}
Aplikasi web modern dibagi menjadi dua bagian utama:
\begin{enumerate}
    \item Frontend (sisi klien) adalah bagian yang berjalan di browser pengguna, terdiri dari:\\
    \begin{itemize}
        \item HTML: struktur dan konten halaman
        \item CSS: tampilan visual halaman
        \item JavaScript: logika interaktif dan komunikasi dengan backend
    \end{itemize}
    \item Backend (sisi server) adalah bagian yang berjalan di server, bertanggung jawab atas logika bisnis dan pemrosesan data. Backend menerima permintaan dari frontend melalui API, melakukan komputasi yang diperlukan, lalu mengembalikan hasilnya ke frontend.
\end{enumerate}

\subsubsection{Struktur HTTP Request}
Sebuah request HTTP umumnya berisi:
\begin{itemize}
    \item Method adalah tindakan yang ingin dilakukan (misalnya GET, POST, dsb)
    \item URL/Endpoint adalah alamat tujuan di server
    \item Headers adalah metadata tambahan, seperti tipe konten atau informasi autentikasi
    \item Body adalah data yang dikirimkan ke server dalam format JSON (umumnya), dan bersifat opsional
\end{itemize}
\\
\textbf{Contoh sederhana:}\\
POST /api/login HTTP/1.1\\
Content-Type: application/json\\
\\
\{"email": "asep@gmail.com", "password": "rahasia"\}

HTTP memiliki beberapa metode atau aksi yang menunjukkan tujuan dari sebuah permintaan. Berikut beberapa metode yang umum:
\begin{itemize}
    \item GET digunakan untuk mengambil data dari server, misalnya ketika browser memuat halaman web. 
    \item POST digunakan untuk mengirim data baru ke server, seperti ketika mengisi formulir pendaftaran.
    \item PUT digunakan untuk memperbarui data yang sudah ada di server
    \item DELETE digunakan untuk menghapus data di server
\end{itemize}
Dengan metode ini, komunikasi client-server menjadi lebih terstruktur. Misalnya ketika frontend mengirimkan: \\
POST /api/login\\
server langsung tahu bahwa itu adalah permintaan untuk login pengguna.\\

\subsubsection{Struktur HTTP Response}
Server kemudian memberikan respons permintaan dengan pesan HTTP yang berisi: 
\begin{itemize}
    \item Status code menunjukkan hasil pemrosesan, misalnya 200 OK atau 404 Not Found
    \item Headers adalah informasi tambahan seperti jenis data dan panjang konten
    \item Body adalah data hasil pemrosesan, seringkali dalam format JSON atau HTML
\end{itemize}
\\
\textbf{Contoh response:}\\
HTTP/1.1 200 OK\\
Content-Type: application/json\\
\\
\{ "status": "success", "token": "abc123xyz"\}\\
\subsection{UI/UX}
User Interface (UI) adalah segala sesuatu yang dapat dilihat dan berinteraksi dengan user. User Experience (UX) adalah pengalaman keseluruhan yang dialami oleh user.
\subsubsection{Design Thinking}
\begin{itemize}
    \item Empathize: Memahami perasaan pengguna
    \item Define: Menetapkan masalah yang dihadapi pengguna
    \item Ideate: Brainstorming ide solusi/produk
    \item Prototype: Realisasi ide produk (design)
    \item Test: Melakukan uji coba ke user, dan melakukan revisi dari feedback
\end{itemize}
Tahap-tahapan design thinking bersifat iteratif, kita dapat kembali ke tahap sebelumnya berdasarkan feedback yang diterima.
\subsubsection{Prototyping with Wireframe}
Wireframe adalah sketsa kasaran dari suatu aplikasi, bisa dalam bentuk coret-coret di kertas atau digital.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{wireframe.png}
\end{figure}
\subsubsection{Designing with Figma}
Figma adalah salah satu tools yang digunakan oleh UI/UX designer. Figma memungkinkan kolaborasi secara real time. 
\subsection{Full Stack Development}
\subsubsection{HTML, CSS, dan Typescript}
HTML (HyperText Markup Language) adalah bahasa markup yang mendefinisikan kerangka dari suatu halaman web. HTML tersusun atas tag <> </> yang menjadi pembuka dan penutup daru suatu elemen. HTML bekerja seperti tree (DOM tree), ada elemen yang menjadi parent dan elemen di dalamnya yang menjadi child. 

CSS (Cascading Style Sheets) adalah bahasa style sheet yang digunakan utnuk mengatur presentasi visual dari dokumen yang ditulis dalam HTML. Jika HTML adalah struktur bangunan, maka CSS adalah arsitek dan desain interiornya. CSS bekerja dengan pola selector, property, dan value. Selector memilih elemen HTML mana yang mau dihias, property menentukan apa yang mau diubah, seperti ukuran dan warna, dan value adalah nilai perubahannya. 

TypeScript (TS) adalah bahasa pemrograman yang berperan sebagai otak yang mengatur perilaku halaman web tersebut agar menjadi cerdas dan interaktif. Pada dasarnya, TS mengatur apa yang terjadi jika suatu tombol diklik, bagaimana data dihitung, dan bagaimana aplikasi merespons input pengguna. 

\subsubsection{Frontend in Svelte}
Framework adalah kerangka kerja yang membantu kerjaan menjadi lebih cepat dan efisien. Aksantara menggunakan framework Svelte karena learning curvenya lebih landai dan aplikasi jauh lebih ringan dan efisien. Seluruh code di-compile menjadi vanilla di JavaScript sehingga lebih ringan dan responsif\\

\textbf{Component-based Architecture}\\
Konsep arsitektur web modern, di mana kta membangun tampilan sebuah aplikasi web bukan sebagai satu halaman web raksasa, melainkan sebagai rangkaian dari komponen-komponen kecil. Kode dibagi menjadi components dalam bentuk file .svelte. Dengan demikian, aplikasi menjadi modular karena setiap elemen di layar GCS dipisah di file-nya sendiri-sendiri. Kalau ada bug di suatu komponen UI, kita cukup cari di file yang bersesuaian dengan komponen tersebut. Component-based Architecture ini meningkatkan reusability karena kompinen yang sudah dibuat bisa dipakai berulang kali di beragam tempat tanpa menulis ulang kodenya. Setiap komponen bersifat self-contained sehingga tidak saling mengganggu komponen lain. \\

\textbf{State Handling}\\
State handling adalah cara menyimpan data dari backend yang kemudian ditampilkan di layar. Pada dasarnya, state adalah sebuah variabel. State bisa bersifat lokal, yakni hanya dipakai oleh internal dari suatu komponen saja. Jika state dibutuhkan oleh banyak komponen, kita bisa mendefinisikan sebuah store yang menyimpan data di luar komponen (mirip variabel lokal). Contoh penggunaannya adalah ketika data altitude dibutuhkan oleh peta, panel navigasi, dan notifikasi atau alert, kita cukup menyimpan data telemetri di satu store lalu tiap komponen yang membutuhkannya tinggal subscribe ka sana. 

\subsubsection{Backend with Go and Python}
Go/Golang adalah bahasa yang dikembangkan Google untuk performa tinggi karena mampu menangani concurrency dengan performa tinggi. Go bersifat type-safe dan mempunyai sintaks yang sederhana. Go digunakan untuk menangani data telemetri dan mengatur lalu lintas data dengan frontend (websockets). 

Python adalah bahasa yang sering digunakan di dunia robotika dan AI. Python memiliki banyak library dan sintaks yang sederhana. Python digunakan untuk pemrosesan berat seperti object detection. 

API adalah cara frontend berkomunikasi dengan frontend. Pada dasarnya, API adalah sekumpulan aturan dan protokol yang memungkinkan dua aplikasi saling berkomunikasi dengan skema request-response. Request yang dikirim oleh frontend tersusun atas method, endpoint, dan payload.
\begin{itemize}
    \item Method adalah jenis tindakan seperti GET, POST, PUT, dan DELETE
    \item Endpoint adalah alamat API tujuan seperti /api/telemetry, /api/command/arm, dsb.
    \item Payload adalah data tambahan, umumnya berformat JSON
\end{itemize}
Response tersusun atas status code (200 OK, 404 Not Found) dan data yang diminta jika ada. 

Websockets digunakan untuk bisa menerima pesan telemetri dari wahana dan mengirimkan command atau waypoints. Koneksi antara frontend dan backend dialin dengan HTTP yang bersifat request-response, di mana frontend harus minta dulu baru dijawab oleh backend. Dalam kasus di mana kita ingin status baterai wahana di-update setiap milidetik, frontend harus melakukan ribuan request per menit. Hal ini boros dan akan menyebabkan delay yang tinggi. 

Websocket adalah teknologi ang memungkinkan kita untuk menjalin komunikasi dua arah (bidirectional) secara simultan lewat satu koneksi yang tetap terbuka (persistent). denagn demikian, begitu ada data telemetry, backend langsung menyemburkan datanya ke frontend dengan latensi rendah. 
\begin{figure} [H]
    \centering
    \includegraphics[width=0.75\linewidth]{websocket.png}
\end{figure}

\subsubsection{Deployment with Docker}
Docker adalah kakas yang membungkus aplikasi, library, dan konfigurasi sebagai suatu container. Container mirip seperti virtual machine, tapi meminjam kernel dari OS utama perangkat kita sehingga lebih ringan. Container memiliki filesystem dan jaringannya sendiri. Container memungkinkan kita untuk menjalankan aplikasi-aplikasi dengan environment, seperti OS, versi library, dsb., yang seragam tanpa perlu meng-install secara manual di laptop kita. 

Cara kerja Docker adalah kita membuat image sebagai blueprint yang mendeskripsikan apa saja library dan kode yang terdapat dalam container kita nantinya. Berdasarkan image tersebut, Docker membangun container yang diinginkan. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{docker.png}
\end{figure}

Dockerfile adalah file teks sederhana tempat kita menulis instruksi untuk membuat image. Dengan Dockerfile, kita bisa menjamin semua orang enggunakan environment yang saa ketika menjalankan aplikasi. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{dockerfile.png}
\end{figure}

Docker compose memungkinkan kita untuk menjalankan banyak container dalam sekali jalan berdasarkan dockerfiles yang sudah dibuat (sehingga kita ga perlu repot jalanin satu per satu frontend, backend, dan database). Kita cukup membuat sebuah file docker-compose.yml untuk menentukan container mana dijalankan di port yang mana. 
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{docker compose.png}
\end{figure}

\section{Hands-on 1: Daspro}
\subsection{Log Progress}
\begin{itemize}
    \item 30/01/2026 8 pm - mulai pengerjaan (brainstorming dan baca spek)
    \item 31/01/2026 1 am - selesai implementasi topic broker, node, dan SimTelemetryNode
    \item 01/02/2026 10 pm - selesai wiring: start 3 SimTelemetryNode dan subscribe dashboard ke 3 topic
    \item 01/02/2026 11 pm - selesai implementasi untuk ambil data terbaru dengan wait\_for()
    \item 02/02/2026 5 pm - selesai implementasi policy
    \item 02/02/2026 6 pm - selesai menambahkan parsing cli args sekalian sambil finishing
    \item 02/02/2026 8 pm - selesai finishing \& testing, dan bikin README
    \item 02/02/2026 8 pm - release v1.0 
\end{itemize}

\subsection{Catatan}
\subsubsection{Brainstorming}
\begin{itemize}
    \item Ada 3 drone simulator berjalan secara paralel (multithreading)
    \item Drone akan mengirim telemetry ke topic broker (publish-subscribe, drone publish data ke broker, dashboard subscribe data dari broker)
    \item Dashboard menampilkan telemetry real time, deteksi low battery dan telemetry stale. 
    \item Pecah task dashboard. Ada yang handle data telemetry (dengan observer pattern), ada yang handle deteksi/alert (dengan strategy pattern)
\end{itemize}
\subsubsection{RAII}
RAII atau Resource Acquisition Is Initialization adalah konsep dalam pemrograman berorientasi objek yang menyatakan bahwa siklus hidup resource terikat secara langsung dengan masa hidup objek. Resource didapatkan (akuisisi) saat konstruksi objek dan dilepaskan secara otomatis saat destruksi objek. 

Why use RAII? C++ tidak memiliki garbage collection otomatis. Garbage collection adalah proses internal yang melepaskan heap memory dan resource lain selama berjalannya program. Kegagalan melepaskan resource yang tidak dipakai disebut \textit{leak} atau kebocoran memori. Resource yang bocor tidak tersedia untuk program lain hingga prosesnya berakhir. 

\subsubsection{Observer Pattern}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{image.png}
\end{figure}
Observer adalah pola desain yang menciptakan relasi one-to-many antar objek. Suatu objek utama dengan status yang menarik disebut denagn subject atau publisher. Objek-objek lain yang ingin melacak preubahan pada status objek utama disebut observers atau subscribers. Kelas publisher memiliki mekanisme subscription, yang terdiri atas sebuah array yang menyimpan referensi ke object-object subscriber dan beberapa metode public untuk operasi pada array subscribernya. Setiap kali terjadi peristiwa/perubahan penting pada publisher, ia akan menghubungi subscribernya dan memanggil metode notification khusus. 

\subsubsection{Strategy Pattern}
Kita bisa bikin policy atau aturan, yang kalau dilanggar akan memicu alert. Pattern ini lebih baik daripada menulis kode kondisional di dashboard supaya dashboard ga diotak-atik dan mudah untuk kita menambahkan aturan baru. Strategy pattern akan menyepakati bentuk kontrak untuk mengecek alert (dengan method evaluate),  tapi caranya bisa berbeda-beda (polymorphism).


\section{Hands-on 2: MAVLink dan SITL}
\subsection{Log Progress}
\begin{itemize}
    \item 30/01/2026 4 pm - selesai install + setup, lanjut ngerjain metode manual
    \item 30/01/2026 6 pm - selesai  rekam metode manual
    \item 31/01/2026 1 pm - lanjut ngerjain metode script/mavsdk
    \item 31/01/2026 11 pm - selesai rekam metode script 
    \item 31/01/2026 11 pm - selesai upload video ke youtube dan upload script ke gist
\end{itemize}

\subsection{Kendala dan Solusi}
\textbf{Kendala:}
\begin{itemize}
    \item awal" aku coba run kode boilerplate just to see berhasil connect atau ga, hasilnya error message "Connection using udp:// is deprecated, please use udpin:// or udpout:// (cli\_arg.cpp:28)"
    \item lalu aku coba udpin dan udpout tapi dua"nya masih ga connect
    \item aku coba cari tau port pake output list, kemudian aku copas untuk gantiin yang ada di kode. tapi kendalanya masih sama.
\end{itemize}

\textbf{Solusi:}
\begin{itemize}
    \item Jujur ini bukan solusi sebenarnya karena aku masih gabisa connect. Lebih kayak solusi alternatif, karena deadline malam ini dan aku stuck di koneksi sekitar 3 jam.
    \item Solusi alternatifnya adalah dengan menggunakan pymavlink. 
    \item Bagian ini akan diupdate jika solusi utama sudah ditemukan.
\end{itemize}

\subsection{Catatan}
Pymavlink adalah pustaka pemrosesan message MAVLink tingkat rendah, yang ditulis dalam Python. Pymavlink biasanya dipakai untuk mengimplementasikan komunikasi MAVLink di berbagai jenis sistem MAVLink, seperti GCS (MAVPROXY), Developer APIs (DroneKit), dan aplikasi MAVLink companion computer. Umumnya, MAVSDK-Python dan DroneKit-Python digunakan dalam aplikasi MAVLink untuk komunikasi dengan autopilot. 

\section{THT 2}
\subsection{Log Progress}
\begin{itemize}
    \item 03/02/2026 10 pm - start pengerjaan THT 2
    \item 03/02/2026 11 pm - selesai mengerjakan soal no 2 bagian a dan b
\end{itemize}

\newpage

\section{Referensi}
\begin{itemize}
    \item \href{https://refactoring.guru/design-patterns}{Design Patterns}
    \item \href{https://jenkov.com/tutorials/java-concurrency/producer-consumer.html}{The Producer Consumer Pattern}
    \item \href {https://mavlink.io/en/mavgen_python/}{Using Pymavlink Libraries (mavgen)}
    \item \href{https://learn.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170}{Object lifetime and resource management (RAII)}
    \item PPT materi saat day pendidikan
\end{itemize}

\end{document}
